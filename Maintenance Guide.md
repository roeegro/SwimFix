
# <center> SwimFix<br> Maintenance Guide</center>

## Table of Contents
1. [Introduction](#Introduction)
2. [Client Side](#)
	* [Routes File](#)
	* [Directory Management](#)
	* [Video Trimmer](#)
	* [Test Generator](#)
	* [Requests Formats](#)
4. [Server Side](#)
	* [Request Parser File](#)
	* [Facade Module](#)
	* [Data_Extractor Module](#)
	* [Data_Analyser Module](#)
	* [Visualizer Module](#)
	* [Evaluator Module](#)
	* [File Management](#)
	* [Configurations](#)
5. [Adding Functionality Schema](#)
6. [Assimilation on New Hardware and Run All Program](#)

## Introduction
Our system has 3 main parts. The first one is the training infrastructure.
For more details, [click here](https://github.com/roeegro/SwimFix/tree/master/training).

The other 2 parts are used for the SwimFix web application and they include a web client part and a server for analysis and evaluation. Both parts written in Python and connect each other with TCP conneciton.

<Join here project hierarchy chart>


## Client Side
The client side is a web interface which supports 2 types of users : usual and admin ones. Usual user interface supports upload of video to the server (for analysis), view data and feedback about technique of previous swimming videos and also participate in forum. Admin users can also add tests and run them in the system in order to examine system's performance. More details about the user interface can be found in this [link](https://github.com/roeegro/SwimFix/tree/master/client).
We used Flask, a python web framework, to write the client side. This library enables the developers to load dynamically web pages with python code, define relations between pages, and even pass parameters from python code to html one.

<Client side structure must be put here>

**![](https://lh3.googleusercontent.com/4rXSsvwTc9hLFd1cDh10kOJAbYD8C5u8kpMKvfwv8FwKyc7tHST1vAkngfZQKVJ80fauS_ijGFq1a8o5vFiXhwmUgjRJLWGGn0v4FTWR0pOMUN93w08Oxol031Lci7-cEo18N8n6)

### Routes File
This is the most important module in the client side. It defines the web links of all the pages and binds them to the relevant html page (appears in templates directory). For each html page, there must be found a function in this .py file which looks as follows:

    @app.route('/', methods=['GET', 'POST'])  # only for home page definition
    @app.route("/<page-name>", methods=['GET', 'POST'])  
    def page_name():
		    <some code>  
           return render_template('page-name.html')

The first line denotes that the next url address is the home page of the site, and it should be placed to this page only. The methods specify the type of requests supported in this page.
The second line binds between the url address to the function below.
In the function there is a code, that frequently connects to the server in order to send requests or/and get responses.
Each function must return a redirection to some html page to be loaded in the browser.
You can pass other arguments to the respective html code by specifying them as follows

    return render_template('page-name.html',param1 = argument1,...)
Using this arguments in the respective html code is done as follows

    {{parameter name}}

> **Note**: Url address definition, function name and html page redirection returned in the end of the function name must be consistent, correlative and named by html and python conventions respectively.

 ### Directory Management
 
 **temp -** Contains zip files with information hold in the server, and some temporal folder which holds files to be shown in the browser.
 
**partial_movies -** Generated by the code and contains intervals of movies to be uploaded to the server. See video trimmer section for more details.

**uploaded_files  -** Generated by the code and contains videos uploaded before from the machine the user works on.

**static -** Contains temp directory and also css, js files, images and other files that are loaded or shown in the html pages shown in temp directory.

**templates -** Contains html code that are loaded by the Flask code as shown in the section above.

### Video Trimmer
Dear Liron, complete this section please.

### Test Generator (test_generator.py, test_generator.ui) 
A module for manual annotation of videos. A guide for user mode can be found at this [link](https://github.com/roeegro/SwimFix/tree/master/client#add-test).
The widgets, and their positions in the window is defined in .ui file. You can open ui files with program that can be found in scripts directory under python directory in programs directory.
Python file code is based on [PyQt5](https://doc.qt.io/qtforpython/) package.
This code manipulates those widgets in the code by QtApplication object which holdes all the widgets defined in the ui file. 
This module has 3 main parts: accessors to the widgets objects, events (for buttons), and some helper functions. The functions in each part are sorted by the alpha-bet for easier navigation.

### Requests Format
In order to connect to the server, TCP connection is handled for each request. There are different types of requests but they all have the same general format.
< Request Type > (< parameter name >: < argument name >)*
Handling those requests in server side are described in this section < link >

## Server Side

The main responsibilities of the server is : 
* Parsing requests from client side. See < Link to parser >
* Extracting key points of swimmer in the video.
* Processing the data extracted from video.
* Using the data to get analytics data for evaluation metrics measuring swimmer technique.
* Management of files.
* Returning responses to the client side. 

### Client Request Parser File
This module is the gate for using functionalities of the server. 
The parser takes the first word in the request, and redirect the request to the matching handler function, with a dictionary binds between the first word and the matching handler as shown:

    requests_dict = {'login': login, 'register': register, 'view_feedbacks_list': view_feedbacks_list,  
      'view_graphs': view_graphs,  
      'forum_view_page': forum_view_page, 'forum_view_topic': forum_view_topic,  
      'forum_topic_name': forum_topic_name,  
      'forum_create_topic': forum_create_topic, 'forum_create_post': forum_create_post, 'add_test': add_test,  
      'run_test': run_test, 'upload': upload, 'upload_image_fix': upload_image_fix,  
      'view_tests_list': view_tests_list, 'view_test_results': view_test_results}

### Facade Module
This module is an API of server's functionality, so each function in this module supplies abstraction of levels in data processing. For example the function `get_angles_csv_from_keypoints_csv` takes csv file with all coordinates of body part and generate csv file with angles by generate vector file, then evaluates the angles from the vector file.

### Data_Extractor Module
This module is the first level in data extraction. Its goal is to extract basic information about body parts coordinates and than process them.
Since the system analyses rowing swimming style the body parts that detected are: nose,neck,right shoulder, right elbow, right wrist, left shoulder, left elbow, and left wrist.

< Image of Open Pose skeleton >

Main functionality supported in this module:

1. `get_keypoints_csv_from_video` 
	function is the first stage in data extraction of video. It receives path to video, and argument named `params` - dictionary which can holds some of OpenPose configurations. The output is a path to csv file named `all _keypoints` with the following format:
rows - for each frame
columns - each body part we have 3 columns : < Body Part >X , < Body Part >Y, < Body Part >Score.
X,Y stands for the coordinates of the specific body part, and Score stands for the confidence score of OpenPose for its estimation.
If the body part appears in hand so we have those 3 columns for each side. We specifying it by L/R (left or right) letter before the body part name.
Those are the columns: 
`[Frame Number,NoseX,NoseY,NoseScore,NeckX,NeckY,  RElbowY,RElbowScore,RWristX,RWristY,RWristScore,LShoulderX,LShoulderY,LShoulderScore.LElbowX,LElbowY,LElbowScore,LWristX,LWristY,LWristScore]`

2. `filter_and_interpolate`
	This is the second stage in data extraction process. This function takes the csv path returned from the first function, and filters records with low score value. If there are closer intervals with high score, the function completes the gap between the intervals by interpolation. Returns path to updated body parts coordinates.

3. `generate_vectors_csv`
	This is the third stage in data extraction process. This function takes the path given in the second function, extracted in the function above, and returns a path to csv file generated in the function, includes the vectors.
	This csv contains rows for each frame, and columns describes the vectors by X,Y coordinates.
	As shown in the skeleton image, the vectors we looks for are: right chest, left chest, right arm, left arm, right forearm, left forearm. The columns format is similar to the format described in the first function in this module.

4. `generate_angles_csv` The last stage in data extraction process. This function takes a path to the vectors csv file got from the function above and calculate the angles between 2 relevant vectors. The format of the csv file is similar to the csvs above and includes for each frame the following angles: right shoulder angle, left shoulder angle, right elbow angle, left elbow angle, righat global shoulder angle , left global shoulder angle ,right global elbow angle and left global elbow angle.

5. There are more helper functions which are called by one or more of the functions above. Some of those functions are used for calculation or some intermediate stages in one of the functions above. Documentation for each function in data_extractor module is found in the code.



 
 



<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM0MDQ2NzkyNyw2MzIyMjE4MzIsLTc1Mz
kwNTk3NSwtNTM0MDE5MDQ4LC0xNzczOTY0NTQ5LC04MTM4NDE3
NTksNDgwMDYzMDI0LC04MzI2NjMwNywxMjI3NjI4MDQwLDE2Nz
U0MjM5NzQsLTE3NjE2NzYwNCwtNTgyNjk3NjI0LDIwNjU5OTky
MzIsMTA4MDc0NDUyLDU5MzQ1NjgyMiwtODQ5NzY4MzYxLC0xMD
I4MDA5MzQ2LC0xMTIyNDIxMTM5LC00Nzc4NDAzNTIsLTY4Mzgx
MjI1MF19
-->