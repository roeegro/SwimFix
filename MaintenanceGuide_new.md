
# <center> SwimFix Maintenance Guide</center>

## Table of Contents
1. [Introduction](#Introduction)
2. [Client Side](#)
	* [Routes File](#)
	* [Gui Utils](#)
	* [Directory Management](#)
	* [Video Trimmer](#)
	* [Test Generator](#)
	* [Requests Formats](#)
4. [Server Side](#)
	* [Request Parser File](#)
	* [Facade Module](#)
	* [Data_Extractor Module](#)
	* [Data_Analyser Module](#)
	* [Visualizer Module](#)
	* [Evaluator Module](#)
	*  [File Management](#)
5. [Adding Functionality Schema](#)
6. [Assimilation on New Hardware and Run All Program](#)

## Introduction
Our system has 3 main parts. The first one is the training infrastructure.
For more details, [click here](https://github.com/roeegro/SwimFix/tree/master/training).

The other 2 parts are used for the SwimFix web application and they include a web client part and a server for analysis and evaluation. Both parts written in Python and connect each other with TCP conneciton.

< Join here project hierarchy chart>


## Client Side
The client side is a web interface which supports 2 types of users : usual and admin ones. Usual user interface supports upload of video to the server (for analysis), view data and feedback about technique of previous swimming videos and also participate in forum. Admin users can also add tests and run them in the system in order to examine system's performance. More details about the user interface can be found in this [link](https://github.com/roeegro/SwimFix/tree/master/client).
We used Flask, a python web framework, to write the client side. This library enables the developers to load dynamically web pages with python code, define relations between pages, and even pass parameters from python code to html one.

<Client side structure must be put here>

**![](https://lh3.googleusercontent.com/4rXSsvwTc9hLFd1cDh10kOJAbYD8C5u8kpMKvfwv8FwKyc7tHST1vAkngfZQKVJ80fauS_ijGFq1a8o5vFiXhwmUgjRJLWGGn0v4FTWR0pOMUN93w08Oxol031Lci7-cEo18N8n6)

### Routes File
This is the most important module in the client side. It defines the web links of all the pages and binds them to the relevant html page (appears in templates directory). For each html page, there must be found a function in this .py file which looks as follows:

    @app.route('/', methods=['GET', 'POST'])  # only for home page definition
    @app.route("/<page-name>", methods=['GET', 'POST'])  
    def page_name():
		    <some code>  
           return render_template('page-name.html')

The first line denotes that the next url address is the home page of the site, and it should be placed to this page only. The methods specify the type of requests supported in this page.
The second line binds between the url address to the function below.
In the function there is a code, that frequently connects to the server in order to send requests or/and get responses.
Each function must return a redirection to some html page to be loaded in the browser.
You can pass other arguments to the respective html code by specifying them as follows

    return render_template('page-name.html',param1 = argument1,...)
Using this arguments in the respective html code is done as follows

    {{parameter name}}

> **Note**: Url address definition, function name and html page redirection returned in the end of the function name must be consistent, correlative and named by html and python conventions respectively.
### Gui Utils
A small module with some functions for files manipulation such as extracting data from zip file got from server, getting specific files from zip, crucifixion with errors map (id and description), to swimmers errors so he/she can see the error description with the relevant frames.
 ### Directory Management
 
 **temp -** Contains zip files with information hold in the server, and some temporal folder which holds files to be shown in the browser.
 
**partial_movies -** Generated by the code and contains intervals of movies to be uploaded to the server. See video trimmer section for more details.

**uploaded_files  -** Generated by the code and contains videos uploaded before from the machine the user works on.

**static -** Contains temp directory and also css, js files, images and other files that are loaded or shown in the html pages shown in temp directory.

**templates -** Contains html code that are loaded by the Flask code as shown in the section above.

### Video Trimmer
Dear Liron, complete this section please.

### Test Generator (test_generator.py, test_generator.ui) 
A module for manual annotation of videos. A guide for user mode can be found at this [link](https://github.com/roeegro/SwimFix/tree/master/client#add-test).
The widgets, and their positions in the window is defined in .ui file. You can open ui files with program that can be found in scripts directory under python directory in programs directory.
Python file code is based on [PyQt5](https://doc.qt.io/qtforpython/) package.
This code manipulates those widgets in the code by QtApplication object which holdes all the widgets defined in the ui file. 
This module has 3 main parts: accessors to the widgets objects, events (for buttons), and some helper functions. The functions in each part are sorted by the alpha-bet for easier navigation.
Pay attention that the save button function sends the files generated by this module to the server, and acknowledge 'routes' module to show success message to the client with some global variable.

### Requests Format
In order to connect to the server, TCP connection is handled for each request. There are different types of requests but they all have the same general format.
< Request Type > (< parameter name >: < argument name >)*
Handling those requests in server side are described in this section < link to client request parser section >

## Server Side

The main responsibilities of the server is : 
* Parsing requests from client side. See < Link to parser section >
* Extracting key points of swimmer in the video.
* Processing the data extracted from video.
* Using the data to get analytics data for evaluation metrics measuring swimmer technique.
* Management of files.
* Returning responses to the client side. 

### Client Request Parser File
This module is the gate for using functionalities of the server. 
The parser takes the first word in the request, and redirect the request to the matching handler function, with a dictionary binds between the first word and the matching handler as shown:

    requests_dict = {'login': login, 'register': register, 'view_feedbacks_list': view_feedbacks_list,  
      'view_graphs': view_graphs,  
      'forum_view_page': forum_view_page, 'forum_view_topic': forum_view_topic,  
      'forum_topic_name': forum_topic_name,  
      'forum_create_topic': forum_create_topic, 'forum_create_post': forum_create_post, 'add_test': add_test,  
      'run_test': run_test, 'upload': upload, 'upload_image_fix': upload_image_fix,  
      'view_tests_list': view_tests_list, 'view_test_results': view_test_results}

### Facade Module
This module is an API of server's functionality, so each function in this module supplies abstraction of levels in data processing. For example the function `get_angles_csv_from_keypoints_csv` takes csv file with all coordinates of body part and generate csv file with angles by generate vector file, then evaluates the angles from the vector file.

### Data_Extractor Module
This module is the first level in data extraction. Its goal is to extract basic information about body parts coordinates and than process them.
Since the system analyses rowing swimming style the body parts that detected are: nose,neck,right shoulder, right elbow, right wrist, left shoulder, left elbow, and left wrist.

< Image of Open Pose skeleton >

Main functionality supported in this module:

1. `get_keypoints_csv_from_video` 
	function is the first stage in data extraction of video. It receives path to video, and argument named `params` - dictionary which can holds some of OpenPose configurations. The output is a path to csv file named `all _keypoints` with the following format:
rows - for each frame
columns - each body part we have 3 columns : < Body Part >X , < Body Part >Y, < Body Part >Score.
X,Y stands for the coordinates of the specific body part, and Score stands for the confidence score of OpenPose for its estimation.
If the body part appears in hand so we have those 3 columns for each side. We specifying it by L/R (left or right) letter before the body part name.
Those are the columns: 
`[Frame Number,NoseX,NoseY,NoseScore,NeckX,NeckY,  RElbowY,RElbowScore,RWristX,RWristY,RWristScore,LShoulderX,LShoulderY,LShoulderScore.LElbowX,LElbowY,LElbowScore,LWristX,LWristY,LWristScore]`

2. `filter_and_interpolate`
	This is the second stage in data extraction process. This function takes the csv path returned from the first function, and filters records with low score value. If there are closer intervals with high score, the function completes the gap between the intervals by interpolation. Returns path to updated body parts coordinates.

3. `generate_vectors_csv`
	This is the third stage in data extraction process. This function takes the path given in the second function, extracted in the function above, and returns a path to csv file generated in the function, includes the vectors.
	This csv contains rows for each frame, and columns describes the vectors by X,Y coordinates.
	As shown in the skeleton image, the vectors we looks for are: right chest, left chest, right arm, left arm, right forearm, left forearm. The columns format is similar to the format described in the first function in this module.

4. `generate_angles_csv` The last stage in data extraction process. This function takes a path to the vectors csv file got from the function above and calculate the angles between 2 relevant vectors. The format of the csv file is similar to the csvs above and includes for each frame the following angles: right shoulder angle, left shoulder angle, right elbow angle, left elbow angle, righat global shoulder angle , left global shoulder angle ,right global elbow angle and left global elbow angle.

5. There are more helper functions which are called by one or more of the functions above. Some of those functions are used for calculation or some intermediate stages in one of the functions above. Documentation for each function in data_extractor module is found in the code.

### Data_Analyser Module

This module should be operated after all stages in data_extractor are finished, This module should calculate advanced measures derived from the coordinates, vectors and angles csv files generated before.
This module is able to calculate:
*  Average time period
* Average angle for each angle.

### Visualizer
 This module plot figures derived from csvs generated in other module.
 In each function in this module, you can control the output file name, the location of this file, which columns will be export into figure, and even how to define the x-axis in the figures. This module enables the developer even to plot multifigures based on the same csvs and even comparison figures based on csv files with the same structure (e.g columns names).

 ### Evaluator
This module gets as an input paths to the body part coordinates after filter and path to csv contains the angles calculated before, and operates each function inside this module, in order to detect errors of technique of the filmed swimmer. The main function of this module is `perfomance_evaluator`.
At the bottom of the module there is a dictionary that binds between the errors description in the function that detects this error, and the main function of this module runs over this dictionary and activate each function with the paths specified above.
The effect of this module is 2 csv files. The first one keeps an id of error and its description, based on the dictionary explained before. The second one includes for each error type defined in the module: the id, and list of frames where the specific error detected.
> **Note**: Each function name and the relevant description entry in the dictionary must be named as follows:
	> Function name : check_< error description with underscores between words>
	Description match to this error must be the description above with spaces seperated between the words (instead of the underscores before).

### File Management
 
The server side includes some directories for files management.

#### videos
each video sent to the server is stored in this directory for future use of the developers.

#### temp
Stores zip files containing relevant content for user's request. Those files sent to the client side and stored in the temp < link> directory in the client side.
#### excepted_data
Stores csvs and videos annotated by the manual tag defined in the test generator< link > .
> **Note**: Csv file names must be named as follows: < video name>_expected.
#### openpose

This directory is not exist in the repository but should be added by the developer to the server side directory. This directory should contain the binaries necessary for execution of this pose estimation library's code. Please see this [link](https://github.com/CMU-Perceptual-Computing-Lab/openpose) in order to build OpenPose on your machine. After building OpenPose, remove into Server/openpose the following directories:
* models
* examples
* build

> **Note**: This directory is necessary for execution of all project.

#### tests

Auto generated directory that holds all test results, based on tester module execution < link >.
The directory structure is as follows:
* Video name
	* frames - directory that contains the frames with OpenPose annotations.
	* ground_truth_data - directory that contains csvs based on csv files appears in excepted < link >.
	* test results - directory contains csvs comparing the same colum values from ground truth csv vs. same column values appears in csv generated by OpenPose exectuion (See data_extractor < link to excepted_data title > ).

#### plug_and_play_functions
Directory for future use, where one python function files would be stored here. Function naming format is identical to the format required here < link to evaluator >

#### output
This directory keeps all the files generated in the modules described before for all clients and videos uploaded.
The output directory has hierarchy for easy navigation and described by the following path for some specific upload of specific video for specific username:

server/output/< specific username>/< video name > /< upload date >/< upload time>
where < upload date> is in format of DD-MM-YY and < upload time> is in format of HH-MM-SS.

Each specific upload contains the following folders:
* frames - with annotations of OpenPose
* swimfix_annotated_frames- with annotations of keypoints used after filter and interpolation of all keypoints (See link < extractor link >).
* analytical_data - contains csv files generated by < extractor link >.
* figures - contains figures generated by < visualizer link>
				 
## Adding Functionality Schema

This is a 0-stage system for swimming technique fix, and you might add new functionality to the system. For this purpose, this guide supplies a simple schema for adding new functionality supported by both client and server side. Follow this steps carefully and everything will be great :)
For this guide, we will call our new functionality new_functionality:
>**Assumption**: We create an empty page without any extra-ordinary feature. 
#### from client side:
1. In client/src/templates, create new-functionality.html.
2. In client/src/routes.py create function with the format shown here < routes link> with respective names to new_functionality.
3. You can help some other function in routes in order to write code sending message to the server, with the following format: < new_request_type > ...

#### from server side:
4. Go to client_request_parser.py file and add in the dictionary in the bottom of the page an entry with 'new_request_type': new_functionality.
5. Create in the same page function named new_functionality that receives all the parameters that the other functions in this page got. You can use those functions to create a code snippet that receives files from client, or sending message or file to the server (if you have to).
6. Create in facade module a function that abstracts the functionality you want to create, and call it from the function you created in section 5.
7. According to your needs, feel free to add new functionalities for other modules existing in the project.

## Assimilation on New Hardware and Run All Program


<!--stackedit_data:
eyJoaXN0b3J5IjpbODUwMjUwMTMxLC0xOTg4OTAzNjMwLDEwMz
I2NzEwMDYsMjE0MzA4OTAwNSwxNjU3MzQ1NjM5LDM2NDc1NTc2
NiwxMTQzMTk4NTA2LC0xMjczMTAzNDcxLDExMjIyNDczNjQsLT
czNzY1ODM4OSwtMjAyMDU2NDY5MywyNjQ4NzE1MDUsLTEzNzg0
OTQzNzldfQ==
-->